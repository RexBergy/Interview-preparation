# backend/game_logic.py

"""
Core game logic and state transformation functions for Interview Quest.

This module is responsible for the fundamental mechanics of the game, including:
- Initializing the game state from a static study plan.
- Calculating player statistics like XP and level based on task completion.
- Formatting the game state into a UI-friendly representation.
"""

import random
from typing import Generator, List, Dict, Tuple, Any
import pandas as pd

from backend.plan_parser import CompletePlan

# --- Constants for Game Balance ---
XP_PER_LEVEL = 500
PLAYER_TITLES = ["Novice", "Apprentice", "Journeyman", "Expert", "Master", "Grandmaster", "Legend"]
DIFFICULTY_LEVELS = ["Normal", "Hard", "Hardest"]
DIFFICULTY_XP_BASE = {"Normal": 50, "Hard": 100, "Hardest": 150}
BOSS_XP_MULTIPLIER = 1.5

def init_game_state(plan: CompletePlan) -> List[Dict[str, Any]]:
    """
    Transforms a static `CompletePlan` object into a dynamic list of game tasks.

    This function enriches the raw plan by adding game-specific attributes like
    difficulty, XP rewards, and status, turning it into an interactive quest board.

    Args:
        plan: The structured study plan generated by the AI agent.

    Returns:
        A list of dictionary objects, where each dictionary represents a single task (quest)
        with all its associated game properties.
    """
    game_tasks: List[Dict[str, Any]] = []
    
    for task_id, (day, task) in enumerate(_flatten_plan_tasks(plan)):
        is_boss = "mock" in task.name.lower()
        difficulty = "Hardest" if is_boss else random.choice(DIFFICULTY_LEVELS)
        
        xp_reward = _calculate_xp(difficulty, task.duration, is_boss)

        game_tasks.append({
            "id": task_id,
            "day": f"Day {day.day}",
            "name": task.name,
            "desc": task.description,
            # The first task is unlocked by default, the rest are locked.
            "status": "UNLOCKED" if task_id == 0 else "LOCKED",
            "xp_reward": xp_reward,
            "type": "BOSS BATTLE" if is_boss else "QUEST",
            "difficulty": difficulty,
            "lives": 3
        })
            
    return game_tasks

def render_quest_board(game_tasks: List[Dict[str, Any]]) -> pd.DataFrame:
    """
    Converts the list of game tasks into a pandas DataFrame for easy UI rendering.

    Args:
        game_tasks: The current list of game tasks.

    Returns:
        A pandas DataFrame formatted for display on the quest board.
    """
    if not game_tasks:
        return pd.DataFrame(columns=["Status", "Timeline", "Quest Objective", "Rewards"])

    board_data = []
    for task in game_tasks:
        # Use more descriptive icons for status.
        status_map = {"COMPLETED": "âœ… DONE", "UNLOCKED": "âš”ï¸ UNLOCKED", "LOCKED": "ðŸ”’ LOCKED"}
        status_icon = status_map.get(task['status'], task['status'])
        
        name = f"ðŸ’€ {task['name'].upper()}" if task['type'] == "BOSS BATTLE" else task['name']

        board_data.append([
            status_icon,
            task['day'],
            name,
            f"+{task['xp_reward']} XP"
        ])
    
    return pd.DataFrame(
        board_data,
        columns=["Status", "Timeline", "Quest Objective", "Rewards"]
    )

def calculate_player_stats(game_tasks: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Calculates the player's current XP, level, title, and progress towards the next level.

    Args:
        game_tasks: The current list of game tasks.

    Returns:
        A dictionary containing all calculated player statistics.
    """
    if not game_tasks:
        return {
            "xp": 0, "level": 1, "title": PLAYER_TITLES[0],
            "xp_in_level": 0, "xp_per_level": XP_PER_LEVEL
        }
        
    current_xp = sum(t['xp_reward'] for t in game_tasks if t['status'] == "COMPLETED")
    
    level = 1 + (current_xp // XP_PER_LEVEL)
    xp_in_level = current_xp % XP_PER_LEVEL
    
    # Ensure the title does not go out of bounds.
    title = PLAYER_TITLES[min(level - 1, len(PLAYER_TITLES) - 1)]
    
    return {
        "xp": current_xp,
        "level": level,
        "title": title,
        "xp_in_level": xp_in_level,
        "xp_per_level": XP_PER_LEVEL
    }

# --- Helper Functions ---

def _flatten_plan_tasks(plan: CompletePlan) -> Generator[Any, Any, Any]:
    """Generator to yield (day, task) tuples from the nested plan object."""
    for day in plan.daily_plans:
        for task in day.tasks:
            yield day, task

def _calculate_xp(difficulty: str, duration: int, is_boss: bool) -> int:
    """Calculates the XP reward for a task based on its properties."""
    base_xp = DIFFICULTY_XP_BASE.get(difficulty, 50)
    # XP bonus for longer tasks.
    duration_xp = duration // 2
    xp = base_xp + duration_xp
    
    if is_boss:
        xp *= BOSS_XP_MULTIPLIER
        
    return int(xp)
